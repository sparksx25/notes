# 算法

- [文档: hello-algorithm 算法](https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#4)
- [github hello-algo](https://github.com/krahets/hello-algo/releases)


## 算法评估
时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势。

时间效率：算法运行速度的快慢。
空间效率：算法占用内存空间的大小。

时间复杂度由多项式 𝑇(𝑛) 中最高阶的项来决定。

𝑂(1) < 𝑂(log 𝑛) < 𝑂(𝑛) < 𝑂(𝑛 log 𝑛) < 𝑂(𝑛2) < 𝑂(2𝑛) < 𝑂(𝑛!)
常数阶 < 对数阶 < 线性阶 < 线性对数阶 < 平方阶 < 指数阶 < 阶乘阶

通常使用最差时间复杂度作为算法效率的评判标准



## 搜索算法
二分查找：针对有序的数据结构
双指针


## 遍历
树的遍历:
- 层序遍历
- 前序遍历
- 中序遍历
- 后续遍历

图的遍历
- 深度优先遍历 (dfs)
- 广度优先遍历（bfs）


## 分治
归并排序：先将问题划分为多个不相关的子问题，回溯时将子问题的解进行**合并**得到原问题的解
- 分（划分阶段）：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。
- 治（合并阶段）：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。

## 回溯
从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止

## 动态规划
- 动态规划会根据之前阶段的所有决策来考虑**当前决策**，并使用过去子问题的解来构建当前子问题的解。

## 贪心算法
- 其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。

## 排序
- 冒泡排序
- 选择排序
- 快速排序
- 插入排序
- 希尔排序
- 基数排序
- 

## 迭代
从指定位置开始遍历全部元素
```typescript
function forEachFromStart(list: any[], start: number){
  for (let i = 0; i < list.length; i++) {
    const item = list[(start + i) % list.length];
  }
}
```


## 案例
斐波那契数列
