# 设计模式

## 模式分类
创建型模式
- 工厂模式
- 单例模式
- 原型模式

行为型模式
- 策略模式
- 观察者模式
- 迭代器模式
- 责任链模式
- 命令模式

结构型模式
- 代理模式
- [适配器模式](./adapter-pattern.md)
- 装饰器模式

## 工厂模式
- 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
- 主要解决：主要解决接口选择的问题。

```ts
function createObject(shape: string){
  if(shape === 'CIRCLE'){
      return new Circle();
  } else if(shape === 'RECTANGLE'){
      return new Rectangle();
  } else if(shape === 'SQUARE'){
      return new Square();
  }
  return null;
}
```

## 单例模式
- 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 主要解决：一个全局使用的类频繁地创建与销毁。


## 迭代器模式
- 意图：提供一种方法顺序访问一个集合对象中各个元素, 而又无须暴露该对象的内部表示。
- 主要解决：对外提供一种遍历整个集合对象的方法，而无需知道集合对象的内部结构
    

## 策略模式
- 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
- 主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。


## 观察者模式
- 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
- 主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

优点：
1. 观察者和被观察者是抽象耦合的。
2. 建立一套触发机制。


## 责任链模式
- 意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
- 主要解决：职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者**解耦**了。


## 代理模式
- 意图：为其他对象提供一种代理以控制对这个对象的访问。
- 主要解决：想在访问一个类时做一些控制


## 命令模式
事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。
何时使用：在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。

## 装饰器模式
主要体现在**功能拓展**

## 控制反转（IoC）
inversion of control

## 依赖注入(DI)
dependency Injection 

# Reference
- [汤姆大叔](https://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html)
- [维基百科: 设计模式](https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA))
- [菜鸟教程: 设计模式](https://www.runoob.com/design-pattern/abstract-factory-pattern.html)

