## Three.js

- [three.js 教程](https://discoverthreejs.com/zh/)
- [open GL](https://learnopengl.com/Getting-started/Coordinate-Systems)

## three
1. 只有在透视投影形成的视锥体内的物体才会被渲染，在视锥体外的物体不会被渲染。
2. 所有的对象，包括网格对象，相机对象默认的位置都是在世界坐标系的原点(0, 0, 0)。
3. three 中的 3D 笛卡尔坐标系（右手系），x正半轴指向屏幕右方，y正半轴指向屏幕上方，z正半轴指向屏幕前方。
4. 保证不同帧率的设备上每秒的变化量是一定的，否则出现帧率快的设备变化更快
5. 当相机的参数发生改变时需要更新投影矩阵(updateProjectionMatrix)。
6. 基于物理的渲染(PBR)： 使用真实世界的物理学来计算表面对光的反应方式，涉及以物理上正确的方式 计算光与表面的反应
7. 物理上正确的照明意味着使用真实世界的物理方程计算 光如何随着与光源的距离（衰减）而衰减


视锥体:
    透视相机从相机坐标位置到观察点位置的连线是视线的方向。近裁剪面与视线的坐标由相机的坐标和near属性决定。远裁剪面与视线的坐标由相机的坐标和far属性决定。


three.js 中的灯光类分为两种类型：
   - 直接光照，模拟直接光照。
   - 环境光，这是 一种 廉价且可信的间接照明方式


默认情况下禁用阴影
    即使我们使用 PBR，现实世界和 three.js 之间的一个区别是默认情况下对象不会阻挡光线。光路径中的每个物体都会收到照明，即使路上有一堵墙。落在物体上的光会照亮它，但也会直接穿过并照亮后面的物体。物理正确性就这么多！

    我们可以逐个对象的、逐个光照的手动启用阴影。但是，阴影很昂贵，因此我们通常只为一盏灯或两盏灯启用阴影，尤其是当我们的场景需要在移动设备上工作时。只有直接光类型可以投射阴影，环境光不能。


DirectionalLight
    设计的目的是模仿遥远的光源，例如太阳。来自`DirectionalLight`的光线不会随着距离而消失。场景中的所有对象都将被同样明亮地照亮，无论它们放在哪里——即使是在灯光后面。


空间变换
    欧拉角有几个缺点，在创建动画或进行涉及旋转的数学时会变得很明显。特别是，我们不能将两个欧拉角相加（更著名的是，它们还存在一种叫做 万向锁的问题）。四元数没有这些缺点。另一方面，它们比欧拉角更难使用，所以现在我们将坚持使用更简单的Euler类

MeshBasicMaterial
    MeshBasicMaterial 不执行基于视角或距离的着色。它只是简单地使用物体的颜色。这对于调试非常有用，因为它可以让我们看到物体的颜色，而**不必考虑光照**。

面剔除设备:
    Three.js 默认会进行面剔除（Face Culling），也就是只渲染物体朝外的面，而不渲染朝内的面。当相机处于封闭物体内部时，由于看不到朝外的面，所以可能感觉没有内容渲染。不过，你可以通过修改材质的 side 属性来改变面剔除行为。设置 side: THREE.DoubleSide 后，材质会同时渲染物体的内外两面，这样相机在物体内部就能看到物体的内部结构了。


FQ:
1. 如果相机位于被观察物体的内部，是否可以成像，能否看到物体？

```ts
// 设置设备像素比
renderer.setPixelRatio(window.devicePixelRatio);

// 旧版的写法
// turn on the physically correct lighting model
renderer.physicallyCorrectLights = true;

```