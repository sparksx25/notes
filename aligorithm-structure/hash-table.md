# 哈希表(hash table)

## 介绍
- 哈希表又称散列表。    
- 哈希表的常见操作包括：初始化、查询操作、添加键值对和删除键值对等
- 哈希表的实现：通常使用数组加链表实现

## 概念
- 哈希函数（hash function）: 将 key 通过计算映射为数组的索引，尽量保证映射成唯一索引，性能更高。
- 哈希冲突（ hash collision）： 不同 key 通过哈希函数计算出相同的值。
- 负载因子（load factor）：是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希
冲突的严重程度，也常被作为哈希表扩容的触发条件。例如在 Java 中，当负载因子超过 0.75 时，系统会将
哈希表容量扩展为原先的 2 倍。

## 哈希函数
输入一个 key，哈希函数的计算过程分为以下两步。
1. 通过某种哈希算法 hash() 计算得到哈希值。
2. 将哈希值对桶数量（数组长度）capacity 取模，从而获取该 key 对应的数组索引 index 。
   
## 哈希冲突
1. 改良哈希表数据结构，使得哈希表可以在存在哈希冲突时正常工作。哈希表的结构改良方法主要包括“链式地址”和“开放寻址”     
  - 链式地址: 数组的元素是链表或列表，冲突的键值对添加到该链表或列表中
  - 开放寻址：线性探测，多次哈希

2. 仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。

## 相关编程语言
Java 采用链式地址。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会被转
换为红黑树以提升查找性能。


## 哈希算法
而无论是开放寻址还是链地址法，它
们只能保证哈希表可以在发生冲突时正常工作，但无法减少哈希冲突的发生。

简单 hash 算法：
- 加法哈希：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值。
- 乘法哈希：利用了乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中。

标准哈希算法: 
它们可以将任意长度的输入数据映射到恒定长度的哈希值。
- MD5 和 SHA‑1 已多次被成功攻击，因此它们被各类安全应用弃用。
- SHA‑2 系列中的 SHA‑256 是最安全的哈希算法之一，仍未出现成功的攻击案例，因此常被用在各类安
全应用与协议中。
- SHA‑3 相较 SHA‑2 的实现开销更低、计算效率更高，但目前使用覆盖度不如 SHA‑2 系列。

```typescript
/* 加法哈希 */
function addHash(key: string): number {
  let hash = 0;
  const MODULUS = 1000000007;
  for (const c of key) {
    hash = (hash + c.charCodeAt(0)) % MODULUS;
  }
  return hash;
}
/* 乘法哈希 */
function mulHash(key: string): number {
  let hash = 0;
  const MODULUS = 1000000007;
  for (const c of key) {
    hash = (31 * hash + c.charCodeAt(0)) % MODULUS;
  }
  return hash;
}
```
